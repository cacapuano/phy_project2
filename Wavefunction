import numpy as np
import matplotlib.pyplot as plt

# Constants
hbar = 1.0  # Planck's constant (JÂ·s)
m = 3.0  # Electron mass (kg)

# Potential function
def potentiall(x):
    if x > 0 and x < 1:
      V = 0
    else:
      V = 10000000
    return V

# Define the system of first-order ODEs
def derivativess(x, y, E):
    psi1 = y[0]
    psi2 = y[1]
    V = potentiall(x)
    dpsi1_dx = psi2
    dpsi2_dx = (2 * m / hbar**2) * (V - E) * psi1
    return np.array([dpsi1_dx, dpsi2_dx])

# Runge-Kutta 4th order method
def runge_kutta_4th_orderr(E, y0, x0, x_end, dx):
    num_steps = int((x_end - x0) / dx) + 1
    x_values = np.linspace(x0, x_end, num_steps)
    y_values = np.zeros((num_steps, len(y0)))
    y_values[0] = y0

    for i in range(num_steps - 1):
        x = x_values[i]
        y = y_values[i]

        k1 = dx * derivativess(x, y, E)
        k2 = dx * derivativess(x + dx / 2, y + k1 / 2, E)
        k3 = dx * derivativess(x + dx / 2, y + k2 / 2, E)
        k4 = dx * derivativess(x + dx, y + k3, E)

        y_values[i + 1] = y + (k1 + 2 * k2 + 2 * k3 + k4) / 6

    return x_values, y_values

# Parameters
E = 2        # Energy level (Joules) - you can adjust this
y0 = np.array([1, 0])  # Initial wave function (small amplitude, zero derivative)
x0 = 0        # Start position (m)
x_end = 1      # End position (m)
dx = 0.01        # Step size

# Solve the ODE using Runge-Kutta
x_values, solution = runge_kutta_4th_orderr(E, y0, x0, x_end, dx)

# Extract wave function and its derivative
psi = solution[:, 0]

# Normalize the wave function
norm = 1.5*np.sqrt(np.trapz(np.abs(psi)**2, x_values))
psi /= norm

# Plot the results
plt.figure(figsize=(10, 6))
plt.plot(x_values, np.abs(psi)**2, label='Probability Density', color='blue')
plt.title('Wave Function Probability Density')
plt.xlabel('Position (m)')
plt.ylabel('Probability Density')
plt.grid()
plt.legend()
plt.show()
